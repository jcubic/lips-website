"use strict";(self.webpackChunknew_docs=self.webpackChunknew_docs||[]).push([[4985],{7169:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var i=t(5893),r=t(1151);const s={sidebar_position:4,description:"Environments in LIPS are first class objects"},a="Environments",c={id:"lips/environments",title:"Environments",description:"Environments in LIPS are first class objects",source:"@site/docs/lips/environments.md",sourceDirName:"lips",slug:"/lips/environments",permalink:"/lips-website/docs/lips/environments",draft:!1,unlisted:!1,editUrl:"https://github.com/jcubic/lips-website/tree/docusaurus/docs/docs/lips/environments.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,description:"Environments in LIPS are first class objects"},sidebar:"tutorialSidebar",previous:{title:"SXML",permalink:"/lips-website/docs/lips/sxml"},next:{title:"Functional and other utils",permalink:"/lips-website/docs/lips/functional-helpers"}},o={},l=[{value:"Environment chain",id:"environment-chain",level:2},{value:"Changing environment without eval",id:"changing-environment-without-eval",level:2},{value:"Introspection",id:"introspection",level:2},{value:"Frames",id:"frames",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"environments",children:"Environments"}),"\n",(0,i.jsxs)(n.p,{children:["Environments in LIPS are first class objects that you can interact with.\nScheme spec define procedure ",(0,i.jsx)(n.code,{children:"(interactive-environment)"})," LIPS add also ",(0,i.jsx)(n.code,{children:"(current-environment)"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scheme",children:"(let ((x 10))\n  (eval '(+ x x) (current-environment)))\n;; ==> 20\n"})}),"\n",(0,i.jsx)(n.h2,{id:"environment-chain",children:"Environment chain"}),"\n",(0,i.jsx)(n.p,{children:"Environments are created in a chain. In JavaScript there is a notion of scope chain the same,\nis in Scheme. But with environment object you can access that chain."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scheme",children:"(let ((x 10))\n  (let ((x 20))\n    (print (eval '(+ x x) (current-environment)))\n    (print (eval '(+ x x) (. (current-environment) '__parent__)))))\n;; ==> 40\n;; ==> 20\n"})}),"\n",(0,i.jsx)(n.h2,{id:"changing-environment-without-eval",children:"Changing environment without eval"}),"\n",(0,i.jsxs)(n.p,{children:["In LIPS you can change the environment with ",(0,i.jsx)(n.code,{children:"let-env"})," syntax:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scheme",children:"(define env (let ((x 10) (y 20))\n              (current-environment)))\n\n(let-env env\n  (+ x y))\n;; ==> 30\n"})}),"\n",(0,i.jsx)(n.h2,{id:"introspection",children:"Introspection"}),"\n",(0,i.jsxs)(n.p,{children:["Since environments are JavaScript objects you can access it's properties like ",(0,i.jsx)(n.code,{children:"__name__"})," or ",(0,i.jsx)(n.code,{children:"__env__"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scheme",children:'(let ((x 10) (y 20))\n  (write (Object.keys (. (current-environment) \'__env__))))\n;; ==> #("x" "y")\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"__env__"})," property is an object with the variables. Here it returns variables defined in let."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scheme",children:'(let ((x 10) (y 20))\n  (let ((env (current-environment)))\n    (write env.__name__)))\n;; ==> "let"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here you can acccess name of the lexical environment."}),"\n",(0,i.jsx)(n.h2,{id:"frames",children:"Frames"}),"\n",(0,i.jsxs)(n.p,{children:["In LIPS inspired by ",(0,i.jsx)(n.a,{href:"http://adv-r.had.co.nz/Environments.html",children:"R programming language"}),", there are\ntwo procedures ",(0,i.jsx)(n.code,{children:"parent.frame"})," and ",(0,i.jsx)(n.code,{children:"parent.frames"})," you can use them to get access to function\ncall stack environments."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scheme",children:"(define (foo)\n  (define x 10)\n  (bar))\n\n(define (bar)\n  (define x 20)\n  (baz))\n\n(define (baz)\n   (for-each (lambda (env)\n                (let-env env\n                  (print x)))\n     ;; car is top level environment\n     (cdr (parent.frames))))\n(foo)\n;; ==> 10\n;; ==> 20\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can mix lexical scope chain with frames:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scheme",children:'(define (foo)\n  (define x 10)\n  (let ((y "world"))\n    (bar)))\n\n(define (bar)\n  (define x 20)\n  (let ((y "hello"))\n    (baz)))\n\n(define (baz)\n   (for-each (lambda (env)\n               (display env.__name__)\n               (display " ==> ")\n               (print (Object.keys env.__env__))\n               (display env.__parent__.__name__)\n               (display " ==> ")\n               (print (Object.keys env.__parent__.__env__)))\n     ;; car is top level environment\n     (cdr (parent.frames))))\n(foo)\n;; ==> let ==> #(y)\n;; ==> lambda ==> #(arguments parent.frame x)\n;; ==> let ==> #(y)\n;; ==> lambda ==> #(arguments parent.frame x)\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>a});var i=t(7294);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);