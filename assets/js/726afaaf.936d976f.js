"use strict";(self.webpackChunknew_docs=self.webpackChunknew_docs||[]).push([[5747],{1349:(e,n,a)=>{a.r(n),a.d(n,{default:()=>p});var t=a(7294),r=a(9386),c=a(2263),o=a(8596),i=a(2503),s=a(5742),d=a(1207);const l=JSON.parse('[{"name":"-","doc":"(- n1 n2 ...)\\n(- n)\\n\\nSubtracts n2 and subsequent numbers from n1. If only one argument is passed\\nit will negate the value."},{"name":".","doc":"(. obj . args)\\n(get obj . args)\\n\\nThis function uses an object as a base and keeps using arguments to get the\\nproperty of JavaScript object. Arguments need to be a strings.\\ne.g. `(. console \\"log\\")` if you use any function inside LIPS it\\nwill be weakly bound (can be rebound), so you can call this log function\\nwithout problem unlike in JavaScript when you use\\n`var log = console.log`.\\n`get` is an alias because . doesn\'t work everywhere, e.g. you can\'t\\npass it as an argument."},{"name":"*","doc":"(* . numbers)\\n\\nMultiplies all numbers passed as arguments. If single value is passed\\nit will return that value."},{"name":"**","doc":"(** a b)\\n\\nFunction that calculates number a to to the power of b."},{"name":"/","doc":"(/ n1 n2 ...)\\n(/ n)\\n\\nDivides n1 by n2 and subsequent arguments one by one. If single argument\\nis passed it will calculate (/ 1 n)."},{"name":"&","doc":"(& a b)\\n\\nFunction that calculates the bitwise and operation."},{"name":"+","doc":"(+ . numbers)\\n\\nSums all numbers passed as arguments. If single value is passed it will\\nreturn that value."},{"name":"<","doc":"(< x1 x2 ...)\\n\\nFunction that compares its numerical arguments and checks if they are\\nmonotonically increasing, i.e. x1 < x2 and x2 < x3 and so on."},{"name":"<<","doc":"(<< a b)\\n\\nFunction that left shifts the value a by value b bits."},{"name":"<=","doc":"(<= x1 x2 ...)\\n\\nFunction that compares its numerical arguments and checks if they are\\nmonotonically nondecreasing, i.e. x1 <= x2 and x2 <= x3 and so on."},{"name":"==","doc":"(== x1 x2 ...)\\n\\nFunction that compares its numerical arguments and checks if they are\\nall equal."},{"name":">","doc":"(> x1 x2 x3 ...)\\n\\nFunction that compares its numerical arguments and checks if they are\\nmonotonically decreasing, i.e. x1 > x2 and x2 > x3 and so on."},{"name":">=","doc":"(>= x1 x2 ...)\\n\\nFunction that compares its numerical arguments and checks if they are\\nmonotonically nonincreasing, i.e. x1 >= x2 and x2 >= x3 and so on."},{"name":">>","doc":"(>> a b)\\n\\nFunction that right shifts the value a by value b bits."},{"name":"|","doc":"(| a b)\\n\\nFunction that calculates the bitwise or operation."},{"name":"~","doc":"(~ number)\\n\\nFunction that calculates the bitwise inverse (flip all the bits)."},{"name":"1-","doc":"(1- number)\\n\\nFunction that subtracts 1 from the number and return result."},{"name":"1+","doc":"(1+ number)\\n\\nFunction that adds 1 to the number and return result."},{"name":"abs","doc":"(abs number)\\n\\nFunction that returns the absolute value (magnitude) of number."},{"name":"and","doc":"(and . expressions)\\n\\nMacro that evaluates each expression in sequence and if any value returns false\\nit will stop and return false. If each value returns true it will return the\\nlast value. If it\'s called without arguments it will return true."},{"name":"append","doc":"(append item ...)\\n\\nFunction that creates a new list with each argument appended end-to-end.\\nIt will always return a new list and not modify its arguments."},{"name":"append!","doc":"(append! arg1 ...)\\n\\nDestructive version of append, it can modify the lists in place. It returns\\na new list where each argument is appended to the end. It may modify\\nlists added as arguments."},{"name":"apply","doc":"(apply fn list)\\n\\nFunction that calls fn with the list of arguments."},{"name":"array->list","doc":"(array->list array)\\n\\nFunction that converts a JavaScript array to a LIPS cons list."},{"name":"array?","doc":"(array? expression)\\n\\nPredicate that tests if value is an array."},{"name":"begin","doc":"(begin . args)\\n\\nMacro that runs a list of expressions in order and returns the value\\nof the last one. It can be used in places where you can only have a\\nsingle expression, like (if)."},{"name":"begin*","doc":"(begin* . body)\\n\\nThis macro is a parallel version of begin. It evaluates each expression\\nin the body and if it\'s a promise it will await it in parallel and return\\nthe value of the last expression (i.e. it uses Promise.all())."},{"name":"boolean?","doc":"(boolean? expression)\\n\\nPredicate that tests if value is a boolean (#t or #f)."},{"name":"caaaaar","doc":"(caaaaar arg)\\n\\nFunction that calculates (car (car (car (car (car arg)))))"},{"name":"caaaadr","doc":"(caaaadr arg)\\n\\nFunction that calculates (car (car (car (car (cdr arg)))))"},{"name":"caaaar","doc":"(caaaar arg)\\n\\nFunction that calculates (car (car (car (car arg))))"},{"name":"caaadar","doc":"(caaadar arg)\\n\\nFunction that calculates (car (car (car (cdr (car arg)))))"},{"name":"caaaddr","doc":"(caaaddr arg)\\n\\nFunction that calculates (car (car (car (cdr (cdr arg)))))"},{"name":"caaadr","doc":"(caaadr arg)\\n\\nFunction that calculates (car (car (car (cdr arg))))"},{"name":"caaar","doc":"(caaar arg)\\n\\nFunction that calculates (car (car (car arg)))"},{"name":"caadaar","doc":"(caadaar arg)\\n\\nFunction that calculates (car (car (cdr (car (car arg)))))"},{"name":"caadadr","doc":"(caadadr arg)\\n\\nFunction that calculates (car (car (cdr (car (cdr arg)))))"},{"name":"caadar","doc":"(caadar arg)\\n\\nFunction that calculates (car (car (cdr (car arg))))"},{"name":"caaddar","doc":"(caaddar arg)\\n\\nFunction that calculates (car (car (cdr (cdr (car arg)))))"},{"name":"caadddr","doc":"(caadddr arg)\\n\\nFunction that calculates (car (car (cdr (cdr (cdr arg)))))"},{"name":"caaddr","doc":"(caaddr arg)\\n\\nFunction that calculates (car (car (cdr (cdr arg))))"},{"name":"caadr","doc":"(caadr arg)\\n\\nFunction that calculates (car (car (cdr arg)))"},{"name":"caar","doc":"(caar arg)\\n\\nFunction that calculates (car (car arg))"},{"name":"cadaaar","doc":"(cadaaar arg)\\n\\nFunction that calculates (car (cdr (car (car (car arg)))))"},{"name":"cadaadr","doc":"(cadaadr arg)\\n\\nFunction that calculates (car (cdr (car (car (cdr arg)))))"},{"name":"cadaar","doc":"(cadaar arg)\\n\\nFunction that calculates (car (cdr (car (car arg))))"},{"name":"cadadar","doc":"(cadadar arg)\\n\\nFunction that calculates (car (cdr (car (cdr (car arg)))))"},{"name":"cadaddr","doc":"(cadaddr arg)\\n\\nFunction that calculates (car (cdr (car (cdr (cdr arg)))))"},{"name":"cadadr","doc":"(cadadr arg)\\n\\nFunction that calculates (car (cdr (car (cdr arg))))"},{"name":"cadar","doc":"(cadar arg)\\n\\nFunction that calculates (car (cdr (car arg)))"},{"name":"caddaar","doc":"(caddaar arg)\\n\\nFunction that calculates (car (cdr (cdr (car (car arg)))))"},{"name":"caddadr","doc":"(caddadr arg)\\n\\nFunction that calculates (car (cdr (cdr (car (cdr arg)))))"},{"name":"caddar","doc":"(caddar arg)\\n\\nFunction that calculates (car (cdr (cdr (car arg))))"},{"name":"cadddar","doc":"(cadddar arg)\\n\\nFunction that calculates (car (cdr (cdr (cdr (car arg)))))"},{"name":"caddddr","doc":"(caddddr arg)\\n\\nFunction that calculates (car (cdr (cdr (cdr (cdr arg)))))"},{"name":"cadddr","doc":"(cadddr arg)\\n\\nFunction that calculates (car (cdr (cdr (cdr arg))))"},{"name":"caddr","doc":"(caddr arg)\\n\\nFunction that calculates (car (cdr (cdr arg)))"},{"name":"cadr","doc":"(cadr arg)\\n\\nFunction that calculates (car (cdr arg))"},{"name":"call-with-values","doc":"(call-with-values producer consumer)\\n\\nCalls the producer procedure with no arguments, then calls the\\nconsumer procedure with the returned value as an argument -- unless\\nthe returned value is a special Values object created by (values), if it is\\nthe values are unpacked and the consumer is called with multiple arguments."},{"name":"call/cc","doc":"(call/cc proc)\\n\\nCall-with-current-continuation.\\n\\nNOT SUPPORTED BY LIPS RIGHT NOW"},{"name":"car","doc":"(car pair)\\n\\nThis function returns the car (item 1) of the list."},{"name":"cdaaaar","doc":"(cdaaaar arg)\\n\\nFunction that calculates (cdr (car (car (car (car arg)))))"},{"name":"cdaaadr","doc":"(cdaaadr arg)\\n\\nFunction that calculates (cdr (car (car (car (cdr arg)))))"},{"name":"cdaaar","doc":"(cdaaar arg)\\n\\nFunction that calculates (cdr (car (car (car arg))))"},{"name":"cdaadar","doc":"(cdaadar arg)\\n\\nFunction that calculates (cdr (car (car (cdr (car arg)))))"},{"name":"cdaaddr","doc":"(cdaaddr arg)\\n\\nFunction that calculates (cdr (car (car (cdr (cdr arg)))))"},{"name":"cdaadr","doc":"(cdaadr arg)\\n\\nFunction that calculates (cdr (car (car (cdr arg))))"},{"name":"cdaar","doc":"(cdaar arg)\\n\\nFunction that calculates (cdr (car (car arg)))"},{"name":"cdadaar","doc":"(cdadaar arg)\\n\\nFunction that calculates (cdr (car (cdr (car (car arg)))))"},{"name":"cdadadr","doc":"(cdadadr arg)\\n\\nFunction that calculates (cdr (car (cdr (car (cdr arg)))))"},{"name":"cdadar","doc":"(cdadar arg)\\n\\nFunction that calculates (cdr (car (cdr (car arg))))"},{"name":"cdaddar","doc":"(cdaddar arg)\\n\\nFunction that calculates (cdr (car (cdr (cdr (car arg)))))"},{"name":"cdadddr","doc":"(cdadddr arg)\\n\\nFunction that calculates (cdr (car (cdr (cdr (cdr arg)))))"},{"name":"cdaddr","doc":"(cdaddr arg)\\n\\nFunction that calculates (cdr (car (cdr (cdr arg))))"},{"name":"cdadr","doc":"(cdadr arg)\\n\\nFunction that calculates (cdr (car (cdr arg)))"},{"name":"cdar","doc":"(cdar arg)\\n\\nFunction that calculates (cdr (car arg))"},{"name":"cddaaar","doc":"(cddaaar arg)\\n\\nFunction that calculates (cdr (cdr (car (car (car arg)))))"},{"name":"cddaadr","doc":"(cddaadr arg)\\n\\nFunction that calculates (cdr (cdr (car (car (cdr arg)))))"},{"name":"cddaar","doc":"(cddaar arg)\\n\\nFunction that calculates (cdr (cdr (car (car arg))))"},{"name":"cddadar","doc":"(cddadar arg)\\n\\nFunction that calculates (cdr (cdr (car (cdr (car arg)))))"},{"name":"cddaddr","doc":"(cddaddr arg)\\n\\nFunction that calculates (cdr (cdr (car (cdr (cdr arg)))))"},{"name":"cddadr","doc":"(cddadr arg)\\n\\nFunction that calculates (cdr (cdr (car (cdr arg))))"},{"name":"cddar","doc":"(cddar arg)\\n\\nFunction that calculates (cdr (cdr (car arg)))"},{"name":"cdddaar","doc":"(cdddaar arg)\\n\\nFunction that calculates (cdr (cdr (cdr (car (car arg)))))"},{"name":"cdddadr","doc":"(cdddadr arg)\\n\\nFunction that calculates (cdr (cdr (cdr (car (cdr arg)))))"},{"name":"cdddar","doc":"(cdddar arg)\\n\\nFunction that calculates (cdr (cdr (cdr (car arg))))"},{"name":"cddddar","doc":"(cddddar arg)\\n\\nFunction that calculates (cdr (cdr (cdr (cdr (car arg)))))"},{"name":"cdddddr","doc":"(cdddddr arg)\\n\\nFunction that calculates (cdr (cdr (cdr (cdr (cdr arg)))))"},{"name":"cddddr","doc":"(cddddr arg)\\n\\nFunction that calculates (cdr (cdr (cdr (cdr arg))))"},{"name":"cdddr","doc":"(cdddr arg)\\n\\nFunction that calculates (cdr (cdr (cdr arg)))"},{"name":"cddr","doc":"(cddr arg)\\n\\nFunction that calculates (cdr (cdr arg))"},{"name":"cdr","doc":"(cdr pair)\\n\\nThis function returns the cdr (all but first) of the list."},{"name":"ceiling","doc":"(ceiling number)\\n\\nFunction that calculates the ceiling of a number."},{"name":"clone","doc":"(clone list)\\n\\nFunction that returns a clone of the list, that does not share any pairs with the\\noriginal, so the clone can be safely mutated without affecting the original."},{"name":"compose","doc":"(compose . fns)\\n\\nHigher-order function that creates a new function that applies all functions\\nfrom right to left and returns the last value. Reverse of pipe.\\ne.g.:\\n((compose (curry + 2) (curry * 3)) 10) --\x3e (+ 2 (* 3 10)) --\x3e 32"},{"name":"concat","doc":"(concat . strings)\\n\\nFunction that creates a new string by joining its arguments."},{"name":"cons","doc":"(cons left right)\\n\\nThis function returns a new list with the first appended\\nbefore the second. If the second is not a list cons will\\nreturn a dotted pair."},{"name":"continuation?","doc":"(continuation? expression)\\n\\nPredicate that tests if value is a callable continuation."},{"name":"current-environment","doc":"(current-environment)\\n\\nFunction that returns the current environment (they\'re first-class objects!)"},{"name":"curry","doc":"(curry fn . args)\\n\\nHigher-order function that creates a curried version of the function.\\nThe result function will have partially applied arguments and it\\nwill keep returning one-argument functions until all arguments are provided,\\nthen it calls the original function with the accumulated arguments.\\n\\ne.g.:\\n(define (add a b c d) (+ a b c d))\\n(define add1 (curry add 1))\\n(define add12 (add 2))\\n(display (add12 3 4))"},{"name":"debugger","doc":"(debugger)\\n\\nFunction that triggers the JavaScript debugger (e.g. the browser devtools)\\nusing the \\"debugger;\\" statement. If a debugger is not running this\\nfunction does nothing."},{"name":"define","doc":"(define name expression)\\n(define name expression \\"doc string\\")\\n(define (function-name . args) . body)\\n\\nMacro for defining values. It can be used to define variables,\\nor functions. If the first argument is list it will create a function\\nwith name being first element of the list. This form expands to\\n`(define function-name (lambda args body))`"},{"name":"define-macro","doc":"(define-macro (name . args) body)\\n\\nThe meta-macro, that creates new macros. If the return value is a list structure\\nit will be evaluated where the macro is invoked from. You can use quasiquote `\\nand unquote , and unquote-splicing ,@ inside to create an expression that will be\\nevaluated at runtime. Macros works like this: if you pass any expression to a\\nmacro the arguments will not be evaluated unless the macro\'s body explicitly\\ncalls (eval) on it. Because of this a macro can manipulate the expression\\n(arguments) as lists."},{"name":"define-syntax-parameter","doc":"(define-syntax-parameter name syntax [__doc__])\\n\\nBinds <keyword> to the transformer obtained by evaluating <transformer spec>.\\nThe transformer provides the default expansion for the syntax parameter,\\nand in the absence of syntax-parameterize, is functionally equivalent to\\ndefine-syntax."},{"name":"display","doc":"(display string [port])\\n\\nThis function outputs the string to the standard output or\\nthe port if given. No newline."},{"name":"display-error","doc":"(display-error . args)\\n\\nDisplay an error message on stderr."},{"name":"do","doc":"(do ((<var> <init> <next>)) (test return) . body)\\n\\nIteration macro that evaluates the expression body in scope of the variables.\\nOn each loop it changes the variables according to the <next> expression and runs\\ntest to check if the loop should continue. If test is a single value, the macro\\nwill return undefined. If the test is a pair of expressions the macro will\\nevaluate and return the second expression after the loop exits."},{"name":"empty?","doc":"(empty? object)\\n\\nFunction that returns #t if value is nil (an empty list) or undefined."},{"name":"env","doc":"(env)\\n(env obj)\\n\\nFunction that returns a list of names (functions, macros and variables)\\nthat are bound in the current environment or one of its parents."},{"name":"eq?","doc":"(eq? a b)\\n\\nFunction that compares two values if they are identical."},{"name":"escape-regex","doc":"(escape-regex string)\\n\\nFunction that returns a new string where all special operators used in regex,\\nare escaped with backslashes so they can be used in the RegExp constructor\\nto match a literal string."},{"name":"eval","doc":"(eval expr)\\n(eval expr environment)\\n\\nFunction that evaluates LIPS Scheme code. If the second argument is provided\\nit will be the environment that the code is evaluated in."},{"name":"even?","doc":"(even? number)\\n\\nChecks if number is even."},{"name":"filter","doc":"(filter fn list)\\n(filter regex list)\\n\\nHigher-order function that calls `fn` for each element of the list\\nand return a new list for only those elements for which fn returns\\na truthy value. If called with a regex it will create a matcher function."},{"name":"find","doc":"(find fn list)\\n(find regex list)\\n\\nHigher-order function that finds the first value for which fn return true.\\nIf called with a regex it will create a matcher function."},{"name":"flatten","doc":"(flatten list)\\n\\nReturns a shallow list from tree structure (pairs)."},{"name":"floor","doc":"(floor number)\\n\\nFunction that calculates the floor of a number."},{"name":"fold","doc":"(fold fn init . lists)\\n\\nFunction fold is left-to-right reversal of reduce. It call `fn`\\non each pair of elements of the list and returns a single value.\\ne.g. it computes (fn \'a \'x (fn \'b \'y (fn \'c \'z \'foo)))\\nfor: (fold fn \'foo \'(a b c) \'(x y z))"},{"name":"for-each","doc":"(for-each fn . lists)\\n\\nHigher-order function that calls function `fn` on each\\nvalue of the argument. If you provide more than one list\\nit will take each value from each list and call `fn` function\\nwith that many arguments as number of list arguments."},{"name":"format","doc":"(format string n1 n2 ...)\\n\\nThis function accepts a string template and replaces any\\nescape sequences in its inputs:\\n\\n* ~a value as if printed with `display`\\n* ~s value as if printed with `write`\\n* ~% newline character\\n* ~~ literal tilde \'~\'\\n\\nIf there are missing inputs or other escape characters it\\nwill error."},{"name":"function?","doc":"(function? expression)\\n\\nPredicate that tests if value is a callable function."},{"name":"gcd","doc":"(gcd n1 n2 ...)\\n\\nFunction that returns the greatest common divisor of the arguments."},{"name":"gensym","doc":"(gensym)\\n\\nGenerates a unique symbol that is not bound anywhere,\\nto use with macros as meta name."},{"name":"get","doc":"(. obj . args)\\n(get obj . args)\\n\\nThis function uses an object as a base and keeps using arguments to get the\\nproperty of JavaScript object. Arguments need to be a strings.\\ne.g. `(. console \\"log\\")` if you use any function inside LIPS it\\nwill be weakly bound (can be rebound), so you can call this log function\\nwithout problem unlike in JavaScript when you use\\n`var log = console.log`.\\n`get` is an alias because . doesn\'t work everywhere, e.g. you can\'t\\npass it as an argument."},{"name":"help","doc":"(help object)\\n\\nThis macro returns documentation for a function or macro.\\nYou can save the function or macro in a variable and use it\\nhere. But getting help for a variable requires passing the\\nvariable in a `quote`."},{"name":"if","doc":"(if cond true-expr false-expr)\\n\\nMacro that evaluates cond expression and if the value is true, it\\nevaluates and returns true-expression, if not it evaluates and returns\\nfalse-expression."},{"name":"ignore","doc":"(ignore . body)\\n\\nMacro that will evaluate the expression and swallow any promises that may\\nbe created. It will discard any value that may be returned by the last body\\nexpression. The code should have side effects and/or when it\'s promise\\nit should resolve to undefined."},{"name":"in","doc":"(in key value)\\n\\nFunction that uses the Javascript \\"in\\" operator to check if key is\\na valid property in the value."},{"name":"instance?","doc":"(instance? obj)\\n\\nChecks if object is an instance, created with a new operator"},{"name":"instanceof","doc":"(instanceof type obj)\\n\\nPredicate that tests if the obj is an instance of type."},{"name":"join","doc":"(join separator list)\\n\\nFunction that returns a string by joining elements of the list using separator."},{"name":"lambda","doc":"(lambda (a b) body)\\n(lambda args body)\\n(lambda (a b . rest) body)\\n\\nThe lambda macro creates a new anonymous function. If the first element of\\nthe body is a string and there is more elements the string is used as the\\ndocumentation string, that can be read using (help fn)."},{"name":"lcm","doc":"(lcm n1 n2 ...)\\n\\nFunction that returns the least common multiple of the arguments."},{"name":"length","doc":"(length expression)\\n\\nFunction that returns the length of the object. The object can be a LIPS\\nlist or any object that has a \\"length\\" property. Returns undefined if the\\nlength could not be found."},{"name":"let","doc":"(let ((a value-a) (b value-b) ...) . body)\\n\\nMacro that creates a new environment, then evaluates and assigns values to names,\\nand then evaluates the body in context of that environment.  Values are evaluated\\nsequentially but you can\'t access previous values/names when the next are\\nevaluated. You can only get them in the body of the let expression.  (If you want\\nto define multiple variables and use them in each other\'s definitions, use\\n`let*`.)"},{"name":"let-env","doc":"(let-env env . body)\\n\\nSpecial macro that evaluates body in context of given environment\\nobject."},{"name":"let*","doc":"(let* ((a value-a) (b value-b) ...) . body)\\n\\nMacro similar to `let`, but the subsequent bindings after the first\\nare evaluated in the environment including the previous let variables,\\nso you can define one variable, and use it in the next\'s definition."},{"name":"letrec","doc":"(letrec ((a value-a) (b value-b) ...) . body)\\n\\nMacro that creates a new environment, then evaluates and assigns values to\\nnames and then evaluates the body in context of that environment.\\nValues are evaluated sequentially and the next value can access the\\nprevious values/names."},{"name":"letrec*","doc":"(letrec* ((a value-a) (b value-b) ...) . body)\\n\\nSame as letrec but the order of execution of the binding is guaranteed,\\nso you can use recursive code as well as referencing the previous binding.\\n\\nIn LIPS both letrec and letrec* behave the same."},{"name":"list","doc":"(list . args)\\n\\nFunction that creates a new list out of its arguments."},{"name":"list->array","doc":"(list->array list)\\n\\nFunction that converts a LIPS list into a JavaScript array."},{"name":"list?","doc":"(list? obj)\\n\\nPredicate that tests if value is a proper linked list structure.\\nThe car of each pair can be any value. It returns false on cyclic lists.\\""},{"name":"load","doc":"(load filename)\\n(load filename environment)\\n\\nFetches the file (from disk or network) and evaluates its content as LIPS code.\\nIf the second argument is provided and it\'s an environment the evaluation\\nwill happen in that environment."},{"name":"macro?","doc":"(macro? expression)\\n\\nPredicate that tests if value is a macro."},{"name":"macroexpand","doc":"(macroexpand expr)\\n\\nMacro that expand all macros inside and return single expression as output."},{"name":"macroexpand-1","doc":"(macroexpand-1 expr)\\n\\nMacro similar to macroexpand but it expand macros only one level\\nand return single expression as output."},{"name":"make-parameter","doc":"(make-parameter init converter)\\n\\nFunction creates new dynamic variable that can be custimized with parameterize\\nmacro. The value should be assigned to a variable e.g.:\\n\\n(define radix (make-parameter 10))\\n\\nThe result value is a procedure that return the value of dynamic variable."},{"name":"map","doc":"(map fn . lists)\\n\\nHigher-order function that calls function `fn` with each\\nvalue of the list. If you provide more then one list as argument\\nit will take each value from each list and call `fn` function\\nwith that many argument as number of list arguments. The return\\nvalues of the fn calls are accumulated in a result list and\\nreturned by map."},{"name":"match","doc":"(match pattern string)\\n\\nFunction that returns a match object from JavaScript as a list or #f if\\nno match."},{"name":"new","doc":"(new obj . args)\\n\\nFunction that creates new JavaScript instance of an object."},{"name":"not","doc":"(not object)\\n\\nFunction that returns the Boolean negation of its argument."},{"name":"nth","doc":"(nth index obj)\\n\\nFunction that returns the nth element of the list or array.\\nIf used with a non-indexable value it will error."},{"name":"null-environment","doc":"(null-environment)\\n\\nReturns a clean environment with only the standard library."},{"name":"null?","doc":"(null? expression)\\n\\nPredicate that tests if value is null-ish (i.e. undefined, nil, or\\nJavascript null)."},{"name":"number?","doc":"(number? expression)\\n\\nPredicate that tests if value is a number or NaN value."},{"name":"object?","doc":"(object? expression)\\n\\nPredicate that tests if value is an plain object (not another LIPS type)."},{"name":"odd?","doc":"(odd? number)\\n\\nChecks if number is odd."},{"name":"or","doc":"(or . expressions)\\n\\nMacro that executes the values one by one and returns the first that is\\na truthy value. If there are no expressions that evaluate to true it\\nreturns false."},{"name":"pair?","doc":"(pair? expression)\\n\\nPredicate that tests if value is a pair or list structure."},{"name":"parameterize","doc":"(parameterize ((name value) ...)\\n\\nMacro that change the dynamic variable created by make-parameter."},{"name":"parent.frame","doc":"(parent.frame)\\n\\nReturns the parent environment if called from inside a function.\\nIf no parent frame can be found it returns nil."},{"name":"peek-char","doc":"(peek-char port)\\n\\nThis function reads and returns a character from the string\\nport, or, if there is no more data in the string port, it\\nreturns an EOF."},{"name":"pipe","doc":"(pipe . fns)\\n\\nHigher-order function that creates a new function that applies all functions\\nfrom left to right and returns the last value. Reverse of compose.\\ne.g.:\\n((pipe (curry + 2) (curry * 3)) 10) --\x3e (* 3 (+ 2 10)) --\x3e 36"},{"name":"pluck","doc":"(pluck . strings)\\n\\nIf called with a single string it will return a function that when\\ncalled with an object will return that key from the object.\\nIf called with more then one string the returned function will\\ncreate a new object by copying all properties from the given object."},{"name":"pprint","doc":"(pprint expression)\\n\\nThis function will pretty print its input to stdout. If it is called\\nwith a non-list, it will just call the print function on its\\ninput."},{"name":"print","doc":"(print . args)\\n\\nThis function converts each input into a string and prints\\nthe result to the standard output (by default it\'s the\\nconsole but it can be defined in user code). This function\\ncalls `(newline)` after printing each input."},{"name":"prototype?","doc":"(prototype? obj)\\n\\nPredicate that tests if value is a valid JavaScript prototype,\\ni.e. calling (new) with it will not throw \'<x> is not a constructor\'."},{"name":"quasiquote","doc":"(quasiquote list)\\n\\nSimilar macro to `quote` but inside it you can use special expressions (unquote\\nx) abbreviated to ,x that will evaluate x and insert its value verbatim or\\n(unquote-splicing x) abbreviated to ,@x that will evaluate x and splice the value\\ninto the result. Best used with macros but it can be used outside."},{"name":"quote","doc":"(quote expression) or \'expression\\n\\nMacro that returns a single LIPS expression as data (it won\'t evaluate the\\nargument). It will return a list if put in front of LIPS code.\\nAnd if put in front of a symbol it will return the symbol itself, not the value\\nbound to that name."},{"name":"raise","doc":"(raise obj)\\n\\nThrows the object verbatim (no wrapping an a new Error)."},{"name":"read","doc":"(read [port])\\n\\nThis function, if called with a port, it will parse the next\\nitem from the port. If called without an input, it will read\\na string from standard input (using the browser\'s prompt or\\na user defined input method) and parse it. This function can be\\nused together with `eval` to evaluate code from port."},{"name":"read-char","doc":"(read-char port)\\n\\nThis function reads and returns the next character from the\\ninput port."},{"name":"read-line","doc":"(read-line port)\\n\\nThis function reads and returns the next line from the input\\nport."},{"name":"real?","doc":"(real? number)\\n\\nPredicate that tests if value is a real number (not complex)."},{"name":"reduce","doc":"(reduce fn init list . lists)\\n\\nHigher-order function that takes each element of the list and calls\\nthe fn with result of previous call or init and the next element\\nof the list until each element is processed, and returns a single value\\nas result of last call to `fn` function.\\ne.g. it computes (fn \'c \'z (fn \'b \'y (fn \'a \'x \'foo)))\\nfor: (reduce fn \'foo \'(a b c) \'(x y z))"},{"name":"regex?","doc":"(regex? expression)\\n\\nPredicate that tests if value is a regular expression."},{"name":"replace","doc":"(replace pattern replacement string)\\n\\nFunction that changes pattern to replacement inside string. Pattern can be a\\nstring or regex and replacement can be function or string. See Javascript\\nString.replace()."},{"name":"repr","doc":"(repr obj)\\n\\nFunction that returns a LIPS code representation of the object as a string."},{"name":"reverse","doc":"(reverse list)\\n\\nFunction that reverses the list or array. If value is not a list\\nor array it will error."},{"name":"round","doc":"(round number)\\n\\nFunction that calculates the round of a number."},{"name":"search","doc":"(search pattern string)\\n\\nFunction that returns the first found index of the pattern inside a string."},{"name":"set-car!","doc":"(set-car! obj value)\\n\\nFunction that sets the car (first item) of the list/pair to specified value.\\nThe old value is lost."},{"name":"set-cdr!","doc":"(set-cdr! obj value)\\n\\nFunction that sets the cdr (tail) of the list/pair to specified value.\\nIt will destroy the list. The old tail is lost."},{"name":"set-obj!","doc":"(set-obj! obj key value)\\n(set-obj! obj key value props)\\n\\nFunction set a property of a JavaScript object. props should be a vector of pairs,\\npassed to Object.defineProperty."},{"name":"set-special!","doc":"(set-special! symbol name [type])\\n\\nAdd a special symbol to the list of transforming operators by the parser.\\ne.g.: `(add-special! \\"#\\" \'x)` will allow to use `#(1 2 3)` and it will be\\ntransformed into (x (1 2 3)) so you can write x macro that will process\\nthe list. 3rd argument is optional, and it can be one of two values:\\nlips.specials.LITERAL, which is the default behavior, or\\nlips.specials.SPLICE which causes the value to be unpacked into the expression.\\nThis can be used for e.g. to make `#(1 2 3)` into (x 1 2 3) that is needed\\nby # that defines vectors."},{"name":"set!","doc":"(set! name value)\\n\\nMacro that can be used to set the value of the variable or slot (mutate it).\\nset! searches the scope chain until it finds first non empty slot and sets it."},{"name":"shuffle","doc":"(shuffle obj)\\n\\nOrder items in vector or list in random order."},{"name":"some","doc":"(some fn list)\\n\\nHigher-order function that calls fn on each element of the list.\\nIt stops and returns true when fn returns true for a value.\\nIf none of the values give true, some will return false.\\nAnalogous to Python any(map(fn, list))."},{"name":"split","doc":"(split separator string)\\n\\nFunction that creates a list by splitting string by separator which can\\nbe a string or regular expression."},{"name":"sqrt","doc":"(sqrt number)\\n\\nFunction that returns the square root of the number."},{"name":"string->number","doc":"(string->number number [radix])\\n\\nFunction that parses a string into a number."},{"name":"string?","doc":"(string? expression)\\n\\nPredicate that tests if value is a string."},{"name":"substring","doc":"(substring string start end)\\n\\nFunction that returns the slice of the string starting at start and ending\\nwith end."},{"name":"symbol?","doc":"(symbol? expression)\\n\\nPredicate that tests if value is a LIPS symbol."},{"name":"syntax-parameterize","doc":"(syntax-parameterize (bindings) body)\\n\\nMacro work similar to let-syntax but the the bindnds will be exposed to the user.\\nWith syntax-parameterize you can define anaphoric macros."},{"name":"syntax-rules","doc":"(syntax-rules () (pattern expression) ...)\\n\\nBase of hygienic macros, it will return a new syntax expander\\nthat works like Lisp macros."},{"name":"throw","doc":"(throw string)\\n\\nThrows a new exception."},{"name":"tree->array","doc":"(tree->array list)\\n\\nFunction that converts a LIPS cons tree structure into a JavaScript array."},{"name":"truncate","doc":"(truncate n)\\n\\nFunction that returns the integer part (floor) of a real number."},{"name":"try","doc":"(try expr (catch (e) code))\\n(try expr (catch (e) code) (finally code))\\n(try expr (finally code))\\n\\nMacro that executes expr and catches any exceptions thrown. If catch is provided\\nit\'s executed when an error is thrown. If finally is provided it\'s always\\nexecuted at the end."},{"name":"type","doc":"(type object)\\n\\nFunction that returns the type of an object as string."},{"name":"typecheck","doc":"(typecheck label value type [position])\\n\\nChecks the type of value and errors if the type is not one allowed.  Type can be\\nstring or list of strings. The position optional argument is used to create a\\nproper error message for the nth argument of function calls."},{"name":"typecheck-number","doc":"(typecheck-number label value type [position])\\n\\nFunction similar to typecheck but checks if the argument is a number\\nand specific type of number e.g. complex."},{"name":"unbind","doc":"(unbind fn)\\n\\nFunction that removes the weak \'this\' binding from a function so you\\ncan get properties from the actual function object."},{"name":"unquote","doc":"(unquote code) or ,code\\n\\nSpecial form used in the quasiquote macro. It evaluates the expression inside and\\nsubstitutes the value into quasiquote\'s result."},{"name":"unquote-splicing","doc":"(unquote-splicing code) or ,@code\\n\\nSpecial form used in the quasiquote macro. It evaluates the expression inside and\\nsplices the list into quasiquote\'s result. If it is not the last element of the\\nexpression, the computed value must be a pair."},{"name":"unset-special!","doc":"(unset-special! name)\\n\\nFunction that removes a special symbol from parser added by `set-special!`,\\nname must be a string."},{"name":"unset!","doc":"(unset! name)\\n\\nFunction to delete the specified name from environment.\\nTrying to access the name afterwards will error."},{"name":"values","doc":"(values a1 a2 ...)\\n\\nIf called with more then one element it will create a special\\nValues object that can be used in the call-with-values function."},{"name":"vector-append","doc":"(vector-append v1 v2 ...)\\n\\nReturns new vector by combining it\'s arguments that should be vectors."},{"name":"while","doc":"(while cond body)\\n\\nCreates a loop, it executes cond and body until cond expression is false."}]');var u=a(5893);const h={includeScore:!0,threshold:.1,ignoreLocation:!0,keys:["doc",{name:"name",weight:2}]},m=()=>{const[e,n]=(0,t.useState)(""),[a,c]=(0,t.useState)(),o=(0,t.useMemo)((()=>l.map((e=>({item:e})))),[l]),i=(0,t.useMemo)((()=>{const e=l.map((e=>{let{doc:n}=e;const a=n.split("\n").map((e=>e.length));return Math.max(...a)}));return Math.max(...e)}),[l]);(0,t.useEffect)((()=>{const e=r.Z.createIndex(h.keys,l);c(e)}),[]);const s=new r.Z(l,h,a),m=e.trim()?s.search(e):o,p={"--length":i};return(0,u.jsxs)("div",{className:d.Z.search,style:p,children:[(0,u.jsxs)("div",{className:d.Z.input,children:[(0,u.jsx)("label",{htmlFor:"term",children:"Search"}),(0,u.jsx)("input",{id:"term",onChange:function(e){n(e.target.value)},value:e})]}),(0,u.jsx)("ul",{children:m.map((e=>{let{item:n}=e;return(0,u.jsxs)("li",{children:[(0,u.jsx)("h2",{children:n.name}),(0,u.jsx)("pre",{children:n.doc})]},n.name)}))})]})};function p(){const{siteConfig:e}=(0,c.Z)();return(0,u.jsxs)(o.Z,{title:e.title,description:e.tagline,children:[(0,u.jsx)(s.Z,{children:(0,u.jsx)("script",{src:"https://cdn.jsdelivr.net/npm/@jcubic/lips@beta/dist/lips.min.js","data-bootstrap":"https://cdn.jsdelivr.net/npm/@jcubic/lips@beta/dist/std.xcb"})}),(0,u.jsxs)("main",{className:d.Z.container,children:[(0,u.jsx)(i.Z,{as:"h2",className:d.Z.header,children:"LIPS Scheme Function and Macro Reference"}),(0,u.jsx)(m,{})]})]})}},1207:(e,n,a)=>{a.d(n,{Z:()=>t});const t={heroBanner:"heroBanner_qdFl",buttons:"buttons_AeoN",container:"container_bfhl",header:"header_gB2a",search:"search_Dg8h",input:"input_wQOC"}}}]);